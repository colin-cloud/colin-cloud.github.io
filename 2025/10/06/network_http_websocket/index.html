<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？ | 我的仓库 | Ashery</title><meta name="author" content="Ashery"><meta name="copyright" content="Ashery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络、HTTP、WebSocket">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？">
<meta property="og:url" content="https://colin-cloud.github.io/2025/10/06/network_http_websocket/index.html">
<meta property="og:site_name" content="我的仓库 | Ashery">
<meta property="og:description" content="计算机网络、HTTP、WebSocket">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://colin-cloud.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-10-05T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-06T14:55:07.805Z">
<meta property="article:author" content="Ashery">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="WebSocket">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://colin-cloud.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？",
  "url": "https://colin-cloud.github.io/2025/10/06/network_http_websocket/",
  "image": "https://colin-cloud.github.io/img/avatar.jpg",
  "datePublished": "2025-10-05T16:00:00.000Z",
  "dateModified": "2025-10-06T14:55:07.805Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ashery",
      "url": "https://colin-cloud.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="../../../../img/favicon.jpg"><link rel="canonical" href="https://colin-cloud.github.io/2025/10/06/network_http_websocket/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="我的仓库 | Ashery" type="application/atom+xml">
</head><body><div id="web_bg" style="background-color: #efefef;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading1.gif" data-original="../img/avatar.jpg" onerror="this.onerror=null;this.src='../img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="../archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="../tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="../index.html"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="../categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="../tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="../archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="../shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="../photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="../music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="../movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="../link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="../comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="../about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(../../../../img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="../../../../index.html"><span class="site-name">我的仓库 | Ashery</span></a><a class="nav-page-title" href="../../../../index.html"><span class="site-name">计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="../index.html"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="../categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="../tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="../archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="../shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="../photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="../music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="../movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="../link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="../comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="../about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-06T14:55:07.805Z" title="更新于 2025-10-06 22:55:07">2025-10-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="../../../../categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="既然有 HTTP 协议，为什么还要有 WebSocket？"></a>既然有 HTTP 协议，为什么还要有 WebSocket？</h1><p>平时我们打开网页，比如购物网站某宝。都是点一下「列表商品」，跳转一下网页就到了「商品详情」。</p>
<p>从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，<strong>前端发一次 HTTP请 求，网站返回一次 HTTP 响应</strong>。这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。</p>
<p>但有没有发现，这种情况下，服务器从来就「不会主动」给客户端发一次消息。就像你喜欢的女生从来不会主动找你一样。</p>
<p>但如果现在，你在刷网页的时候「右下角」突然弹出一个小广告，提示你【一个人在家偷偷才能玩哦】。</p>
<p><strong>求知，好学，勤奋</strong>，这些刻在你 DNA 里的东西都动起来了。</p>
<p>你点开后发现。</p>
<p>长相平平无奇的古某提示你”道士 9 条狗，全服横着走”。</p>
<p>影帝某辉老师跟你说”系兄弟就来砍我”。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/b8cca4b1291f25235bc8df3dddbb6da3.webp"></p>
<p>来都来了，你就选了个角色进到了游戏界面里。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/95e5b4cee384b182d0e604378c3ca00a.webp"></p>
<p>这时候，上来就是一个小怪，从远处走来，然后疯狂拿木棒子抽你。</p>
<p><strong>你全程没点任何一次鼠标</strong>。服务器就自动将怪物的移动数据和攻击数据源源不断发给你了。</p>
<p>这….太暖心了。</p>
<p>感动之余，问题就来了，</p>
<p>像这种<strong>看起来服务器主动发消息给客户端的场景</strong>，是怎么做到的？</p>
<p>在真正回答这个问题之前，我们先来聊下一些相关的知识背景。</p>
<h2 id="使用-HTTP-不断轮询"><a href="#使用-HTTP-不断轮询" class="headerlink" title="使用 HTTP 不断轮询"></a>使用 HTTP 不断轮询</h2><p>其实问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong></p>
<p>最常见的解决方案是，<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong></p>
<p>这其实时一种「<strong>伪</strong>」服务器推的形式。</p>
<p>它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p>
<p>用这种方式的场景也有很多，最常见的就是<strong>扫码登录</strong>。</p>
<p>比如，某信公众号平台，登录页面二维码出现之后，<strong>前端</strong>网页根本不知道用户扫没扫，于是不断去向<strong>后端</strong>服务器询问，看有没有人扫过这个码。而且是以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2 秒内得到及时的反馈，不至于<strong>等太久</strong>。</p>
<p>使用 HTTP 定时轮询</p>
<p>但这样，会有两个比较明显的问题：</p>
<ul>
<li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li>
<li>最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li>
</ul>
<p>使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候<strong>卡顿等个 1~2 秒</strong>，页面才跳转。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/63f9236749344bfdb568495589d9434b.webp"></p>
<p>那么问题又来了，<strong>有没有更好的解决方案？</strong></p>
<p>有，而且实现起来成本还非常低。</p>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3 秒，规定时间内没返回，就认为是超时。</p>
<p>如果我们的 HTTP 请求<strong>将超时设置的很大</strong>，比如 30 秒，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></p>
<p>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/1058a96ba35215c0f30accc3ff5bb824.webp"></p>
<p>比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就<strong>秒跳转</strong>，体验很好。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/10bcbd2ced8e4b5fbc4f8ecb181b3a62.webp"></p>
<p>像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的<strong>长训轮机制</strong>。我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/6173c1d25abc914ef17ee9e534ed6a5f.webp"></p>
<p>像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的<strong>服务器推送</strong>技术，它还有个毫不沾边的英文名，<strong>comet</strong> 技术，大家听过就好。</p>
<p>上面提到的两种解决方案（不断轮询和长轮询），本质上，其实还是客户端主动去取数据。</p>
<p>对于像扫码登录这样的<strong>简单场景</strong>还能用用。但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。</p>
<p>这就得说下 <strong>WebSocket</strong> 了。</p>
<h2 id="WebSocket是什么"><a href="#WebSocket是什么" class="headerlink" title="WebSocket是什么"></a>WebSocket是什么</h2><p>我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p>
<p>而现在使用最广泛的 <code>HTTP/1.1</code>，也是基于 TCP 协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p>
<p>也就是说，好好的全双工 TCP，被 HTTP&#x2F;1.1 用成了半双工。</p>
<p>为什么？</p>
<p>这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。</p>
<p>所以，为了更好的支持这样的场景，我们需要另外一个<strong>基于TCP的新协议</strong>。</p>
<p>于是新的应用层协议<strong>WebSocket</strong>就被设计出来了。</p>
<p>大家别被这个名字给带偏了。虽然名字带了个socket，但其实 <strong>socket 和 WebSocket 之间，就跟雷峰和雷峰塔一样，二者接近毫无关系</strong>。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/3bbe4c5db972513f912d30ba8cbddd65.webp"></p>
<h3 id="怎么建立WebSocket连接"><a href="#怎么建立WebSocket连接" class="headerlink" title="怎么建立WebSocket连接"></a>怎么建立WebSocket连接</h3><p>我们平时刷网页，一般都是在浏览器上刷的，一会刷刷图文，这时候用的是 <strong>HTTP 协议</strong>，一会打开网页游戏，这时候就得切换成我们新介绍的 <strong>WebSocket 协议</strong>。</p>
<p>为了兼容这些使用场景。浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p>
<ul>
<li><p>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</p>
</li>
<li><p>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：</p>
</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure>

<p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p>
<p>如果服务器正好支持升级成 WebSocket 协议。就会走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols\r\n</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket\r\n</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade\r\n</span><br></pre></td></tr></table></figure>

<p>HTTP 状态码&#x3D;200（正常响应）的情况，大家见得多了。101 确实不常见，它其实是指<strong>协议切换</strong>。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/dea71991b336c876cae2e1ebdf03b62d.webp"></p>
<p>之后，浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/117eebe06cc6b35ded3216a95706f080.webp"></p>
<p>就这样经历了一来一回两次 HTTP 握手，WebSocket 就建立完成了，后续双方就可以使用 webscoket 的数据格式进行通信了。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/f4edd3018914fe6eb38fad6aa3fd2d65.webp"></p>
<h3 id="WebSocket抓包"><a href="#WebSocket抓包" class="headerlink" title="WebSocket抓包"></a>WebSocket抓包</h3><p>我们可以用 wireshark 抓个包，实际看下数据包的情况。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/f756ca625523f0f9d40a402465179bbe.webp"></p>
<p>上面这张图，注意画了红框的第 <code>2445</code> 行报文，是 WebSocket 的<strong>第一次握手</strong>，意思是发起了一次带有 <code>特殊Header</code> 的 HTTP 请求。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/82d65f08dad05e6b537ea06b94224a5f.webp"></p>
<p>上面这个图里画了红框的 <code>4714</code> 行报文，就是服务器在得到第一次握手后，响应的<strong>第二次握手</strong>，可以看到这也是个 HTTP 类型的报文，返回的状态码是 101。同时可以看到返回的报文 header 中也带有各种 <code>WebSocket</code> 相关的信息，比如 <code>Sec-WebSocket-Accept</code>。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/382c7699530ea7e7b22f60bb68af21bd.webp"></p>
<p>上面这张图就是全貌了，从截图上的注释可以看出，WebSocket 和 HTTP 一样都是基于 TCP 的协议。<strong>经历了三次 TCP 握手之后，利用 HTTP 协议升级为 WebSocket 协议</strong>。</p>
<p>你在网上可能会看到一种说法：”WebSocket 是基于HTTP的新协议”，<strong>其实这并不对</strong>，因为 WebSocket 只有在建立连接时才用到了 HTTP，<strong>升级完成之后就跟 HTTP 没有任何关系了</strong>。</p>
<p>这就好像你喜欢的女生通过你要到了你大学室友的微信，然后他们自己就聊起来了。你能说这个女生是通过你去跟你室友沟通的吗？不能。你跟 HTTP 一样，都只是个<strong>工具人</strong>。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/2e9d4b1652bdfa1e3ae4bb24f70a1b5a.webp"></p>
<p>这就有点”<strong>借壳生蛋</strong>“的那意思。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/640.webp"></p>
<h3 id="WebSocket-的消息格式"><a href="#WebSocket-的消息格式" class="headerlink" title="WebSocket 的消息格式"></a>WebSocket 的消息格式</h3><p>上面提到在完成协议升级之后，两端就会用webscoket的数据格式进行通信。</p>
<p>数据包在 WebSocket 中被叫做<strong>帧</strong>，我们来看下它的数据格式长什么样子。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/3a63a86e5d7e72a37b9828fc6e65c21f.webp"></p>
<p>这里面字段很多，但我们只需要关注下面这几个。</p>
<p><strong>opcode 字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p>
<ul>
<li>等于 1 ，是指text类型（<code>string</code>）的数据包</li>
<li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li>
<li>等于 8 ，是关闭连接的信号</li>
</ul>
<p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是 <code>字符串&quot;111&quot;</code>，那它的长度就是 <code>3</code>。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/437a076935f82be1d36960c9a4785fbd.webp"></p>
<p>另外，可以看到，我们存放 <strong>payload 长度的字段有好几个</strong>，我们既可以用最前面的 <code>7bit</code>, 也可以用后面的 <code>7+16bit 或 7+64bit。</code></p>
<p>那么问题就来了。</p>
<p>我们知道，在数据层面，大家都是 01 二进制流。我怎么知道<strong>什么情况下应该读 7 bit，什么情况下应该读7+16bit 呢？</strong></p>
<p>WebSocket会用最开始的7bit做标志位。不管接下来的数据有多大，都<strong>先读最先的7个bit</strong>，根据它的取值决定还要不要再读个 16bit 或 64bit。</p>
<ul>
<li>如果<code>最开始的7bit</code>的值是 0~125，那么它就表示了 <strong>payload 全部长度</strong>，只读最开始的<code>7个bit</code>就完事了。</li>
</ul>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/690f5a4deda2de50f3a35eddf0be4d75.webp"></p>
<ul>
<li>如果是 <code>126（0x7E）</code>。那它表示 payload 的长度范围在 <code>126~65535</code> 之间，接下来还需要<strong>再读 16bit</strong>。这16bit会包含 payload 的真实长度。</li>
</ul>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/c815c9dabc02fceb42a98c762705af33.webp"></p>
<ul>
<li>如果是 <code>127（0x7F）</code>。那它表示payload的长度范围<code>&gt;=65536</code>，接下来还需要<strong>再读 64bit</strong>。这 64bit 会包含 payload 的长度。这能放 2 的 64 次方 byte 的数据，换算一下好多个 TB，肯定够用了。</li>
</ul>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/192b22b4fe46e8dfb7b17549306d5998.webp"></p>
<p><strong>payload data 字段</strong>：这里存放的就是真正要传输的数据，在知道了上面的payload长度后，就可以根据这个值去截取对应的数据。</p>
<p>大家有没有发现一个小细节，WebSocket 的数据格式也是<strong>数据头（内含payload长度） + payload data</strong> 的形式。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/d449242f1bf41c6f95a5314ec8311d0d.webp"></p>
<p>这是因为 TCP 协议本身就是全双工，但直接使用<strong>纯裸 TCP </strong>去传输数据，会有<strong>粘包</strong>的”问题”。为了解决这个问题，上层协议一般会用<strong>消息头+消息体</strong>的格式去重新包装要发的数据。</p>
<p>而<strong>消息头</strong>里一般含有<strong>消息体的长度</strong>，通过这个长度可以去截取真正的消息体。</p>
<p>HTTP 协议和大部分 RPC 协议，以及我们今天介绍的 WebSocket 协议，都是这样设计的。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/b91fedb1856897c231b8fb5932b7b2d2.webp"></p>
<h3 id="WebSocket的使用场景"><a href="#WebSocket的使用场景" class="headerlink" title="WebSocket的使用场景"></a>WebSocket的使用场景</h3><p>WebSocket 完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p>
<p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>
<p>回到文章开头的问题，在使用 WebSocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是<strong>服务器逻辑</strong>产生的，对玩家产生的伤害等数据，都需要由<strong>服务器主动发送给客户端</strong>，客户端获得数据后展示对应的效果。</p>
<p><img src="/img/loading1.gif" data-original="/2025/10/06/network_http_websocket/31410d2e885aab55c2c588aad754bb5c.webp"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP&#x2F;1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li>
<li>在 HTTP&#x2F;1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li>
<li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li>
<li>WebSocket 和 socket 几乎没有任何关系，只是叫法相似。</li>
<li>正因为各个浏览器都支持 HTTP 协议，所以 WebSocket 会先利用 HTTP 协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。</li>
</ul>
<blockquote>
<p>转载：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_websocket.html">既然有 HTTP 协议，为什么还要有 WebSocket？</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://colin-cloud.github.io">Ashery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://colin-cloud.github.io/2025/10/06/network_http_websocket/">https://colin-cloud.github.io/2025/10/06/network_http_websocket/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://colin-cloud.github.io" target="_blank">我的仓库 | Ashery</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="../../../../tags/HTTP/">HTTP</a><a class="post-meta__tags" href="../../../../tags/WebSocket/">WebSocket</a></div><div class="post-share"><div class="social-share" data-image="../../../../img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="../network_https_nb/" title="计算机网络_HTTP篇_HTTP/2 牛逼在哪？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机网络_HTTP篇_HTTP/2 牛逼在哪？</div></div><div class="info-2"><div class="info-item-1">HTTP&#x2F;2 牛逼在哪？不多 BB 了，直接发车！ 一起来看看 HTTP&#x2F;2 牛逼在哪？  HTTP&#x2F;1.1 协议的性能问题我们得先要了解下 HTTP&#x2F;1.1 协议存在的性能问题，因为 HTTP&#x2F;2 协议就是把这些性能问题逐个攻破了。 现在的站点相比以前变化太多了，比如：  消息的大小变大了，从几 KB 大小的消息，到几 MB 大小的消息； 页面资源变多了，从每个页面不到 10 个的资源，到每页超 100 多个资源； 内容形式变多样了，从单纯到文本内容，到图片、视频、音频等内容； 实时性要求变高了，对页面的实时性要求的应用越来越多；  这些变化带来的最大性能问题就是 HTTP&#x2F;1.1 的高延迟，延迟高必然影响的就是用户体验。主要原因如下几个：  延迟难以下降，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限； 并发连接有限，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响； 队头阻塞问...</div></div></div></a><a class="pagination-related" href="../network_http_interview/" title="计算机网络_HTTP篇_HTTP 常见面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">计算机网络_HTTP篇_HTTP 常见面试题</div></div><div class="info-2"><div class="info-item-1">HTTP 常见面试题在面试过程中，HTTP 被提问的概率还是比较高的。 我搜集了 6 大类 HTTP 面试常问的题目，同时这 6 大类题跟 HTTP 的发展和演变关联性是比较大的，通过问答 + 图解的形式由浅入深的方式帮助大家进一步的学习和理解 HTTP。  HTTP 基本概念 Get 与 Post HTTP 特性 HTTP 缓存技术 HTTPS 与 HTTP HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变   HTTP 基本概念HTTP 是什么？HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。  能否详细解释「超文本传输协议」？  HTTP 的名字「超文本协议传输」，它可以拆成三个部分：  超文本 传输 协议   1. 「协议」 在生活中，我们也能随处可见「协议」，例如：  刚毕业时会签一个「三方协议」； 找房子时会签一个「租房协议」；   生活中的协议，本质上与计算机中的协议是相同的，协议的特点：  「协」字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="../network_http3/" title="计算机网络_HTTP篇_HTTP&#x2F;3 强势来袭"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">计算机网络_HTTP篇_HTTP&#x2F;3 强势来袭</div></div><div class="info-2"><div class="info-item-1">HTTP&#x2F;3 强势来袭HTTP&#x2F;3 现在（2022 年 5 月）还没正式推出，不过自 2017 年起，HTTP&#x2F;3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。 所以，这次 HTTP&#x2F;3 介绍不会涉及到包格式，只说它的特性。  美中不足的 HTTP&#x2F;2HTTP&#x2F;2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP&#x2F;1.1 的性能，而美中不足的是 HTTP&#x2F;2 协议是基于 TCP 实现的，于是存在的缺陷有三个。  队头阻塞； TCP 与 TLS 的握手时延迟； 网络迁移需要重新连接；  队头阻塞HTTP&#x2F;2 多个请求是跑在一	个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。 比如下图中，Stream 2 有一个 TCP 报文丢失了，那么即使收到了 Stream 3 和 Stream 4 的 TCP 报文，应用层也是无法读取读取的，相当于阻塞了 Stream 3 ...</div></div></div></a><a class="pagination-related" href="../network_http_rpc/" title="计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 RPC？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 RPC？</div></div><div class="info-2"><div class="info-item-1">既然有 HTTP 协议，为什么还要有 RPC？我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？ 于是就到网上去搜。 不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在用一个我们不认识的概念去解释另外一个我们不认识的概念，懂的人不需要看，不懂的人看了还是不懂。 这种看了，又好像没看的感觉，云里雾里的很难受，我懂。 为了避免大家有强烈的审丑疲劳，今天我们来尝试重新换个方式讲一讲。 从 TCP 聊起作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 Socket 进行编程。 这时候，我们可选项一般也就 TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。 类似下面这样。 fd = socket(AF_INET,SOCK_STREAM,0);  其中 SOCK_STREAM，是指使用字节流传输数据，说白了就是 T...</div></div></div></a><a class="pagination-related" href="../network_http_optimize/" title="计算机网络_HTTP篇_HTTP&#x2F;1.1 如何优化？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">计算机网络_HTTP篇_HTTP&#x2F;1.1 如何优化？</div></div><div class="info-2"><div class="info-item-1">HTTP&#x2F;1.1 如何优化？问你一句：「你知道 HTTP&#x2F;1.1 该如何优化吗？」 我们可以从下面这三种优化思路来优化 HTTP&#x2F;1.1 协议：  尽量避免发送 HTTP 请求； 在需要发送 HTTP 请求时，考虑如何减少请求次数； 减少服务器的 HTTP 响应的数据大小；  下面，就针对这三种思路具体看看有哪些优化方法。  如何避免发送 HTTP 请求？这个思路你看到是不是觉得很奇怪，不发送 HTTP 请求，那客户端还怎么和服务器交互数据？小林你这不是耍流氓嘛？ 冷静冷静，你说的没错，客户端当然要向服务器发送请求的。 但是，对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP&#x2F;1.1 的性能肯定肉眼可见的提升。 所以，避免发送 HTTP 请求的方法就是通过缓存技术，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。 那缓存是如何做到的呢？ 客户端会把第一...</div></div></div></a><a class="pagination-related" href="../network_http_interview/" title="计算机网络_HTTP篇_HTTP 常见面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">计算机网络_HTTP篇_HTTP 常见面试题</div></div><div class="info-2"><div class="info-item-1">HTTP 常见面试题在面试过程中，HTTP 被提问的概率还是比较高的。 我搜集了 6 大类 HTTP 面试常问的题目，同时这 6 大类题跟 HTTP 的发展和演变关联性是比较大的，通过问答 + 图解的形式由浅入深的方式帮助大家进一步的学习和理解 HTTP。  HTTP 基本概念 Get 与 Post HTTP 特性 HTTP 缓存技术 HTTPS 与 HTTP HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变   HTTP 基本概念HTTP 是什么？HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。  能否详细解释「超文本传输协议」？  HTTP 的名字「超文本协议传输」，它可以拆成三个部分：  超文本 传输 协议   1. 「协议」 在生活中，我们也能随处可见「协议」，例如：  刚毕业时会签一个「三方协议」； 找房子时会签一个「租房协议」；   生活中的协议，本质上与计算机中的协议是相同的，协议的特点：  「协」字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协...</div></div></div></a><a class="pagination-related" href="../network_https_nb/" title="计算机网络_HTTP篇_HTTP&#x2F;2 牛逼在哪？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">计算机网络_HTTP篇_HTTP&#x2F;2 牛逼在哪？</div></div><div class="info-2"><div class="info-item-1">HTTP&#x2F;2 牛逼在哪？不多 BB 了，直接发车！ 一起来看看 HTTP&#x2F;2 牛逼在哪？  HTTP&#x2F;1.1 协议的性能问题我们得先要了解下 HTTP&#x2F;1.1 协议存在的性能问题，因为 HTTP&#x2F;2 协议就是把这些性能问题逐个攻破了。 现在的站点相比以前变化太多了，比如：  消息的大小变大了，从几 KB 大小的消息，到几 MB 大小的消息； 页面资源变多了，从每个页面不到 10 个的资源，到每页超 100 多个资源； 内容形式变多样了，从单纯到文本内容，到图片、视频、音频等内容； 实时性要求变高了，对页面的实时性要求的应用越来越多；  这些变化带来的最大性能问题就是 HTTP&#x2F;1.1 的高延迟，延迟高必然影响的就是用户体验。主要原因如下几个：  延迟难以下降，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限； 并发连接有限，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响； 队头阻塞问...</div></div></div></a><a class="pagination-related" href="../network_https_ecdhe/" title="计算机网络_HTTP篇_HTTPS ECDHE 握手解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">计算机网络_HTTP篇_HTTPS ECDHE 握手解析</div></div><div class="info-2"><div class="info-item-1">HTTPS ECDHE 握手解析HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。 其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。 我在上一篇已经介绍了 RSA 握手的过程 (opens new window)，今天这一篇就「从理论再到实战抓包」介绍 ECDHE 算法。  离散对数ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。 DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是离散对数。 是不是听到这个数学概念就怂了？不怕，这次不会说离散对数推导的过程，只简单提一下它的数学公式。 离散对数是「离散 + 对数」的两个数学概念的组合，所以我们先来复习一遍对数。 要说起对数，必然要说指数，因为它们是互为反函数，指数就是幂运算，对数是指数的逆运算。 举个栗子，如果以 2 作为底数，那么指数和对数运算公式，如下图所示：  那么对于底数为 2 的时候， 32 的对数是 5，64 的对数是 6，计算过程如下：  对数...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading1.gif" data-original="../img/avatar.jpg" onerror="this.onerror=null;this.src='../img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ashery</div><div class="author-info-description">记录美好生活~</div><div class="site-data"><a href="../archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="../tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/mjh1667002013" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="../tencent:/AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="../mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我的博客~~~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E6%9C%89-HTTP-%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89-WebSocket%EF%BC%9F"><span class="toc-text">既然有 HTTP 协议，为什么还要有 WebSocket？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HTTP-%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2"><span class="toc-text">使用 HTTP 不断轮询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-text">长轮询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">WebSocket是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8BWebSocket%E8%BF%9E%E6%8E%A5"><span class="toc-text">怎么建立WebSocket连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E6%8A%93%E5%8C%85"><span class="toc-text">WebSocket抓包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="toc-text">WebSocket 的消息格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">WebSocket的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../2025/10/06/network_http3/" title="计算机网络_HTTP篇_HTTP/3 强势来袭">计算机网络_HTTP篇_HTTP/3 强势来袭</a><time datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../2025/10/06/network_http_rpc/" title="计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 RPC？">计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 RPC？</a><time datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../2025/10/06/network_http_optimize/" title="计算机网络_HTTP篇_HTTP/1.1 如何优化？">计算机网络_HTTP篇_HTTP/1.1 如何优化？</a><time datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../2025/10/06/network_http_interview/" title="计算机网络_HTTP篇_HTTP 常见面试题">计算机网络_HTTP篇_HTTP 常见面试题</a><time datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="../2025/10/06/network_http_websocket/" title="计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？">计算机网络_HTTP篇_既然有 HTTP 协议，为什么还要有 WebSocket？</a><time datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(../../../../img/bg.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Ashery</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js"></script><script src="../../../../js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>